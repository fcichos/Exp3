---
title: Double Slit Interference
jupyter: python3
format:
  html:
    code-fold: true
crossref:
  fig-title: Figure     # (default is "Figure")
  tbl-title: Tbl     # (default is "Table")
  title-delim: "â€”"   # (default is ":")
  fig-prefix: "Figure"
  eq-prefix: Eq.
  chapters: true
---

```{python}
#| echo: false

import numpy as np
import matplotlib.pyplot as plt

from time import sleep,time
from ipycanvas import MultiCanvas, hold_canvas,Canvas
import matplotlib as mpl
import matplotlib.cm as cm
from matplotlib.patches import Arc
from matplotlib.transforms import Bbox, IdentityTransform, TransformedBbox


class AngleAnnotation(Arc):
    """
    Draws an arc between two vectors which appears circular in display space.
    """
    def __init__(self, xy, p1, p2, size=75, unit="points", ax=None,
                 text="", textposition="inside", text_kw=None, **kwargs):
        """
        Parameters
        ----------
        xy, p1, p2 : tuple or array of two floats
            Center position and two points. Angle annotation is drawn between
            the two vectors connecting *p1* and *p2* with *xy*, respectively.
            Units are data coordinates.

        size : float
            Diameter of the angle annotation in units specified by *unit*.

        unit : str
            One of the following strings to specify the unit of *size*:

            * "pixels": pixels
            * "points": points, use points instead of pixels to not have a
              dependence on the DPI
            * "axes width", "axes height": relative units of Axes width, height
            * "axes min", "axes max": minimum or maximum of relative Axes
              width, height

        ax : `matplotlib.axes.Axes`
            The Axes to add the angle annotation to.

        text : str
            The text to mark the angle with.

        textposition : {"inside", "outside", "edge"}
            Whether to show the text in- or outside the arc. "edge" can be used
            for custom positions anchored at the arc's edge.

        text_kw : dict
            Dictionary of arguments passed to the Annotation.

        **kwargs
            Further parameters are passed to `matplotlib.patches.Arc`. Use this
            to specify, color, linewidth etc. of the arc.

        """
        self.ax = ax or plt.gca()
        self._xydata = xy  # in data coordinates
        self.vec1 = p1
        self.vec2 = p2
        self.size = size
        self.unit = unit
        self.textposition = textposition

        super().__init__(self._xydata, size, size, angle=0.0,
                         theta1=self.theta1, theta2=self.theta2, **kwargs)

        self.set_transform(IdentityTransform())
        self.ax.add_patch(self)

        self.kw = dict(ha="center", va="center",
                       xycoords=IdentityTransform(),
                       xytext=(0, 0), textcoords="offset points",
                       annotation_clip=True)
        self.kw.update(text_kw or {})
        self.text = ax.annotate(text, xy=self._center, **self.kw)

    def get_size(self):
        factor = 1.
        if self.unit == "points":
            factor = self.ax.figure.dpi / 72.
        elif self.unit[:4] == "axes":
            b = TransformedBbox(Bbox.unit(), self.ax.transAxes)
            dic = {"max": max(b.width, b.height),
                   "min": min(b.width, b.height),
                   "width": b.width, "height": b.height}
            factor = dic[self.unit[5:]]
        return self.size * factor

    def set_size(self, size):
        self.size = size

    def get_center_in_pixels(self):
        """return center in pixels"""
        return self.ax.transData.transform(self._xydata)

    def set_center(self, xy):
        """set center in data coordinates"""
        self._xydata = xy

    def get_theta(self, vec):
        vec_in_pixels = self.ax.transData.transform(vec) - self._center
        return np.rad2deg(np.arctan2(vec_in_pixels[1], vec_in_pixels[0]))

    def get_theta1(self):
        return self.get_theta(self.vec1)

    def get_theta2(self):
        return self.get_theta(self.vec2)

    def set_theta(self, angle):
        pass

    # Redefine attributes of the Arc to always give values in pixel space
    _center = property(get_center_in_pixels, set_center)
    theta1 = property(get_theta1, set_theta)
    theta2 = property(get_theta2, set_theta)
    width = property(get_size, set_size)
    height = property(get_size, set_size)

    # The following two methods are needed to update the text position.
    def draw(self, renderer):
        self.update_text()
        super().draw(renderer)

    def update_text(self):
        c = self._center
        s = self.get_size()
        angle_span = (self.theta2 - self.theta1) % 360
        angle = np.deg2rad(self.theta1 + angle_span / 2)
        r = s / 2
        if self.textposition == "inside":
            r = s / np.interp(angle_span, [60, 90, 135, 180],
                                          [3.3, 3.5, 3.8, 4])
        self.text.xy = c + r * np.array([np.cos(angle), np.sin(angle)])
        if self.textposition == "outside":
            def R90(a, r, w, h):
                if a < np.arctan(h/2/(r+w/2)):
                    return np.sqrt((r+w/2)**2 + (np.tan(a)*(r+w/2))**2)
                else:
                    c = np.sqrt((w/2)**2+(h/2)**2)
                    T = np.arcsin(c * np.cos(np.pi/2 - a + np.arcsin(h/2/c))/r)
                    xy = r * np.array([np.cos(a + T), np.sin(a + T)])
                    xy += np.array([w/2, h/2])
                    return np.sqrt(np.sum(xy**2))

            def R(a, r, w, h):
                aa = (a % (np.pi/4))*((a % (np.pi/2)) <= np.pi/4) + \
                     (np.pi/4 - (a % (np.pi/4)))*((a % (np.pi/2)) >= np.pi/4)
                return R90(aa, r, *[w, h][::int(np.sign(np.cos(2*a)))])

            bbox = self.text.get_window_extent()
            X = R(angle, r, bbox.width, bbox.height)
            trans = self.ax.figure.dpi_scale_trans.inverted()
            offs = trans.transform(((X-s/2), 0))[0] * 72
            self.text.set_position([offs*np.cos(angle), offs*np.sin(angle)])

plt.rcParams.update({'font.size': 10,
                     'lines.linewidth': 1,
                     'lines.markersize': 5,
                     'axes.labelsize': 10,
                     'axes.labelpad':0,
                     'xtick.labelsize' : 9,
                     'ytick.labelsize' : 9,
                     'legend.fontsize' : 8,
                     'contour.linewidth' : 1,
                     'xtick.top' : True,
                     'xtick.direction' : 'in',
                     'ytick.right' : True,
                     'ytick.direction' : 'in',
                     'figure.figsize': (4, 3),
                     'axes.titlesize':8})

def get_size(w,h):
    return((w/2.54,h/2.54))

```

#### Two Point Sources - Double Slit Interference
The interference of two point sources is a classic example of wave interference. It is often referred to as double slit interference. The interference pattern is created by two point sources that emit waves with the same wavelength and amplitude. The intereference of the two waves depends then on the path length difference between the two waves


::: {layout-ncol=2}
```{python}
# | code-fold: true
# | fig-cap: Double slit interference as the interference from two point sources on the left and the wave amplitudes on the right. The interference pattern is created by two point sources that emit waves with the same wavelength and amplitude. The intereference of the two waves depends then on the path length difference between the two waves.

def plot_angle(ax, pos, angle, length=0.95, acol="C0", **kwargs):
    vec2 = np.array([np.cos(np.deg2rad(angle)), np.sin(np.deg2rad(angle))])
    xy = np.c_[[length, 0], [0, 0], vec2*length].T + np.array(pos)
    ax.plot(*xy.T, color=acol,ls="--")
    return AngleAnnotation(pos, xy[0], xy[2], ax=ax, **kwargs)



plt.figure(figsize=get_size(12,12))

# Point sources positions
d = 2  # source separation
y1, z1 = 0, -d/2  # source 1
y2, z2 = 0, d/2   # source 2

# Draw circular wavefronts
theta = np.linspace(0, 2*np.pi, 100)
n_circles = 5
wavelength = 2  # spacing between wavefronts

for i in range(n_circles):
    r = i * wavelength
    # Wavefronts from source 1
    plt.plot(r*np.cos(theta) + y1, r*np.sin(theta) + z1, 'b:', alpha=0.5)
    # Wavefronts from source 2
    plt.plot(r*np.cos(theta) + y2, r*np.sin(theta) + z2, 'r:', alpha=0.5)

# Draw screen
screen_z = np.linspace(-10, 10, 100)
screen_y = np.ones_like(screen_z) * 16
plt.plot(screen_y, screen_z, 'k-', linewidth=2, label='Screen')

# Example point on screen
P = np.array([16, 4])  # point coordinates [y, z]

# Draw paths from sources to point P
plt.plot([y1, P[0]], [z1, P[1]], 'b-', label='Path 1')
plt.plot([y2, P[0]], [z2, P[1]], 'r-', label='Path 2')
plt.plot([0, P[0]], [z2, P[1]], 'k-', label='Path 2')

# Calculate and show path lengths
r1 = np.sqrt((P[0]-y1)**2 + (P[1]-z1)**2)
r2 = np.sqrt((P[0]-y2)**2 + (P[1]-z2)**2)
path_diff = abs(r2 - r1)

# Add sources
plt.plot(y1, z1, 'bo', label='Source 1')
plt.plot(y2, z2, 'ro', label='Source 2')

# Label source separation
plt.plot([y1-0.5, y1-0.5], [z1, z2], 'k-', linewidth=1)
plt.text(y1-2, -.2, 'd', fontsize=12)

# Add angle annotation
center = np.array([0, 0])  # center between sources
angle = np.arctan2(P[1], P[0])  # angle to point P
kw = dict(size=500, unit="points", text=r"$\theta$")
plot_angle(plt.gca(), center, angle*180/np.pi, length=16,acol="k",textposition="inside", **kw)

plt.xlabel('y')
plt.ylabel('z')
plt.axis("equal")
plt.axis('off')

plt.show()
```



```{=html}
<head>
    <title>Wave Interference Pattern</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
    </style>
</head>
<body>
<div class="container">
    <div id="plot"></div>
    <div>
        <label for="separation">Source Separation: </label>
        <input type="range" id="separation" min="0.0" max="3.0" value="1" step="0.1">
    </div>
    <div>
        <label for="separation">Wavelength: </label>
        <input type="range" id="wavelength" min="0.2" max="1.0" value="0.532" step="0.01">
    </div>
</div>

<script>
// Set up the dimensions
const width = 300;
const height = 300;
const margin = { top: 20, right: 20, bottom: 20, left: 20 };

// Wave parameters
let wavelength = 0.532;
const amplitude = 1;
let k = 2 * Math.PI / (wavelength*100);
let separation = (1.0*100);

// Create the SVG container
const svg = d3.select("#plot")
    .append("svg")
    .attr("width", width)
    .attr("height", height);

// Create a group for the heatmap
const heatmapGroup = svg.append("g")
    .attr("transform", `translate(${margin.left}, ${margin.top})`);

// Create color scale
const colorScale = d3.scaleSequential(d3.interpolateRdBu)
    .domain([-0.3, 0.3]);

// Create grid data
const gridSize = 200;
const cellWidth = (width - margin.left - margin.right) / gridSize;
const cellHeight = (height - margin.top - margin.bottom) / gridSize;

function calculateWaveAmplitude(x, y, sourceX1, sourceX2) {
    const r1 = Math.sqrt((x - sourceX1) ** 2 + (y - height/2) ** 2);
    const r2 = Math.sqrt((x - sourceX2) ** 2 + (y - height/2) ** 2);

    // Calculate wave amplitudes
    const wave1 = amplitude * Math.cos(k * r1) / Math.sqrt(Math.max(r1, 1));
    const wave2 = amplitude * Math.cos(k * r2) / Math.sqrt(Math.max(r2, 1));

    return wave1 + wave2;
}

function updateHeatmap() {
    const sourceX1 = width/2 - separation/2;
    const sourceX2 = width/2 + separation/2;

    const cells = [];
    for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
            const x = i * cellWidth + margin.left;
            const y = j * cellHeight + margin.top;
            const amplitude = calculateWaveAmplitude(x, y, sourceX1, sourceX2);
            cells.push({
                x: x,
                y: y,
                amplitude: amplitude
            });
        }
    }

    // Update heatmap
    const rects = heatmapGroup.selectAll("rect")
        .data(cells);

    rects.enter()
        .append("rect")
        .merge(rects)
        .attr("x", d => d.x)
        .attr("y", d => d.y)
        .attr("width", cellWidth)
        .attr("height", cellHeight)
        .attr("fill", d => colorScale(d.amplitude));

    rects.exit().remove();

    // Draw source points
    heatmapGroup.selectAll(".source")
        .data([sourceX1, sourceX2])
        .join("circle")
        .attr("class", "source")
        .attr("cx", d => d)
        .attr("cy", height/2)
        .attr("r", 5)
        .attr("fill", "black");
}

// Initial render
updateHeatmap();

// Add slider interaction
d3.select("#separation").on("input", function() {
    separation = +this.value*100;
    updateHeatmap();
});

d3.select("#wavelength").on("input", function() {
    wavelength = +this.value;
    k = 2 * Math.PI / (wavelength*100);
    updateHeatmap();
});

</script>
</body>
```

:::


The interference pattern depends on the relative phase of the two waves. The phase difference can be calculated from the path length difference between the two waves and the path length difference can be calculated considering the angle $\theta$ between the line connecting the two sources and the line connecting the sources to the point on the screen. The path length difference is then given by

$$
\Delta s = s_2 - s_1 = d \sin(\theta)
$$

and consequently the phase difference is given by

$$
\Delta \phi = \frac{2\pi}{\lambda} \Delta s = \frac{2\pi}{\lambda} d \sin(\theta)
$$

::: {.callout-note collapse=true}
## Correct path length difference
The path length difference given above is only approximately correct. The exact calculation would involve the geometry of the problem and the path length difference would be calculated as $\Delta s = \sqrt{d^2 + L^2 - 2dL \cos(\theta)} - \sqrt{d^2 + L^2 - 2dL \cos(\theta)}$.  Note that when observing the pattern on the screen with the help of a lens that is placed at the focal distance from the screen, the two path would correspond to parallel rays and the path length difference assumed above would be correct.
:::

As constructive interference occurs when the phase difference is a multiple of, i.e. $m 2\pi$, the constructive interference will be observed when

$$
\sin(\theta) = m \frac{\lambda}{d}
$$

::: {.callout-note}
## Constructive interference from two sources
Constructive interference from two sources separated by a distance $d$ will be observed at an angle $\theta$ when $\sin(\theta) = m \frac{\lambda}{d}$, where $m$ is an integer.
The orders of the constructive interference are labeled as $m = 0, 1, 2, 3, \ldots$ and the $m=0$ constructive interference is the central maximum. The first order constructive interference angle with scale with the wavelength as $\lambda$ and the inverse distance between the sources as $1/d$, i.e. larger wavelength will lead to larger angles and larger source separation will lead to smaller angles.

This scaling is a common feature in many interference applications and the foundation of spectrocopy!
:::

If the screen is at a distance $L$ from the sources, the angle $\theta$ can be calculated as $\theta = \arctan(y/L)$, where $y$ is the distance from the center of the screen.

Inserting the phase difference into the intensity formula, we get

$$
I = 2 I_1 + 2 I_2 + 2 \sqrt{I_1 I_2} \cos\left(\frac{2\pi d}{\lambda} \sin(\theta)\right)
$$

or when assuming the same intensity from the two sources

$$
I= 4I_0\cos^2\left(\frac{d\pi}{\lambda}\sin(\theta)\right)
$$

The plot below shows this intensity pattern for two sources separated by a distance $d = 2$ Âµm and a wavelength of $\lambda = 0.532$ micrometers.

```{python}
# | code-fold: true
#| fig-cap: Intensity pattern of two sources at a screen at a distance L. The sources are separated by a distance d and the wavelength of the waves is $\lambda$.

# Plot intensity pattern
L = 16  # screen distance
y = np.linspace(-20, 20, 1000)  # screen positions
theta = np.arctan(y/L)  # angles
wavelength = 0.532  # wavelength in micrometers
d = 2  # source separation

# Calculate phase difference
delta_phi = (2*np.pi/wavelength) * d * np.sin(theta)

# Calculate intensity (assuming I1 = I2 = 1)
I = 2 * (1 + np.cos(delta_phi))

plt.figure(figsize=get_size(10,6))
plt.plot(y, I)
plt.xlabel('position y on screen')
plt.ylabel('intensity ')
plt.grid(True, alpha=0.3)
plt.show()
```

The interference from two point sources has immediate consequences for the resolution of optical instruments. The resolution of an optical instrument is the ability to distinguish between two closely spaced objects. The Abbe criterion states the the minimum resolvable distance $d$ between two objects is given by

$$
d = \frac{\lambda}{2 \sin(\theta)}
$$

where $\lambda$ is the wavelength of the light and $\theta$ is the angle subtended by the two objects at the lens. The Abbe criterion is derived from the condition that the microscopy lens has to collect at least the first minimum of the interference pattern of the two objects. This first destructive interference is the information that is needed to separate the two objects from one object.


::: {.callout-note collapse=true}
## Fresnel double mirror and biprism experiment

One of the first experiments that demonstrated the wave nature of light was the Fresnel double mirror experiment. In this experiment, a light source is placed in front of two tilted mirrors. The light is reflected from this mirror to a screen. The interference pattern that is observed on the screen is due to the interference of the light that is reflected from the two mirrors. The interference pattern is similar to the one that is observed in the Young's double slit experiment as the two mirrors "immitate" two virtual light sources behind the tilted mirror.

![Fresnel double mirror experiment](img/fresnel_alt.jpg)

A similar experiment is done with the so-called Fresnel biprism. The Fresnel biprism is a prism that is cut in half and the two halves are separated by a small distance. The light that is incident on the biprism is split into two beams that are then recombined on a screen. The interference pattern that is observed on the screen is due to the interference of the two beams.

![Fresnel double mirror experiment](img/fresnel_biprism.jpg)

:::
